import time
import threading
from typing import Dict, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass
from pathlib import Path
import chromadb
from rich.console import Console

from src.models.models import StudentProfile
from src.tools.long_term_memory import LongTermMemory

console = Console()

@dataclass
class StudentSession:
    """Repr√©sente une session active d'un √©tudiant"""
    student_profile: StudentProfile
    last_activity: datetime
    memory: Optional[LongTermMemory] = None
    session_data: Dict = None
    
    def __post_init__(self):
        if self.session_data is None:
            self.session_data = {}
    
    def update_activity(self):
        """Met √† jour l'horodatage de derni√®re activit√©"""
        self.last_activity = datetime.now()
    
    def is_expired(self, timeout_minutes: int = 30) -> bool:
        """V√©rifie si la session a expir√©"""
        return datetime.now() - self.last_activity > timedelta(minutes=timeout_minutes)

class SessionManager:
    """
    Gestionnaire de sessions pour les √©tudiants
    Maintient les sessions actives en m√©moire et g√®re leur cycle de vie
    """
    
    def __init__(self, data_dir="students_data", session_timeout_minutes=30, cleanup_interval_minutes=10):
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        
        # Sessions actives : {student_id: StudentSession}
        self._active_sessions: Dict[str, StudentSession] = {}
        self._session_lock = threading.RLock()
        
        # Configuration
        self.session_timeout_minutes = session_timeout_minutes
        self.cleanup_interval_minutes = cleanup_interval_minutes
        
        # ChromaDB client partag√© et persistant
        self.chroma_client = self._initialize_persistent_chroma()
        
        # D√©marrer le nettoyage automatique des sessions expir√©es
        self._start_cleanup_thread()
        
        console.print(f"‚úÖ SessionManager initialis√© (timeout: {session_timeout_minutes}min)")
    
    def _initialize_persistent_chroma(self):
        """Initialise ChromaDB avec un chemin persistant (pas unique)"""
        try:
            persistent_path = self.data_dir / "memory_db"
            return chromadb.PersistentClient(path=str(persistent_path))
        except Exception as e:
            console.print(f"‚ö†Ô∏è Erreur ChromaDB: {str(e)}")
            return None
    
    def _start_cleanup_thread(self):
        """D√©marre un thread de nettoyage automatique des sessions expir√©es"""
        def cleanup_loop():
            while True:
                try:
                    time.sleep(self.cleanup_interval_minutes * 60)  # Convertir en secondes
                    self.cleanup_expired_sessions()
                except Exception as e:
                    console.print(f"‚ö†Ô∏è Erreur nettoyage sessions: {str(e)}")
        
        cleanup_thread = threading.Thread(target=cleanup_loop, daemon=True)
        cleanup_thread.start()
    
    def get_or_create_session(self, student_id: str, student_name: Optional[str] = None) -> StudentSession:
        """
        R√©cup√®re une session existante ou en cr√©e une nouvelle
        Thread-safe avec verrous
        """
        with self._session_lock:
            # V√©rifier si la session existe et est valide
            if student_id in self._active_sessions:
                session = self._active_sessions[student_id]
                if not session.is_expired(self.session_timeout_minutes):
                    session.update_activity()
                    return session
                else:
                    # Session expir√©e, la nettoyer
                    console.print(f"üîÑ Session expir√©e pour {student_id}, nettoyage...")
                    self._cleanup_session(student_id)
            
            # Cr√©er une nouvelle session
            return self._create_new_session(student_id, student_name)
    
    def _create_new_session(self, student_id: str, student_name: Optional[str] = None) -> StudentSession:
        """Cr√©e une nouvelle session pour un √©tudiant"""
        try:
            # Charger ou cr√©er le profil √©tudiant
            student_profile = self._load_or_create_student(student_id, student_name)
            
            # Initialiser la m√©moire long terme si ChromaDB disponible
            memory = None
            if self.chroma_client:
                try:
                    memory = LongTermMemory(f"student_{student_id}", client=self.chroma_client)
                    if not memory.test_connection():
                        memory = None
                except Exception as e:
                    console.print(f"‚ö†Ô∏è Erreur m√©moire pour {student_id}: {str(e)}")
                    memory = None
            
            # Cr√©er la session
            session = StudentSession(
                student_profile=student_profile,
                last_activity=datetime.now(),
                memory=memory,
                session_data={}
            )
            
            # Ajouter aux sessions actives
            self._active_sessions[student_id] = session
            
            console.print(f"‚úÖ Nouvelle session cr√©√©e pour {student_profile.name or 'Anonymous'} (ID: {student_id})")
            return session
            
        except Exception as e:
            console.print(f"‚ùå Erreur cr√©ation session {student_id}: {str(e)}")
            raise
    
    def _load_or_create_student(self, student_id: str, student_name: Optional[str] = None) -> StudentProfile:
        """Charge un √©tudiant existant ou en cr√©e un nouveau"""
        student_file = self.data_dir / f"{student_id}.json"
        
        if student_file.exists():
            try:
                import json
                with open(student_file, 'r', encoding='utf-8') as f:
                    return StudentProfile(**json.load(f))
            except Exception as e:
                console.print(f"‚ö†Ô∏è Erreur chargement {student_id}: {str(e)}")
        
        # Cr√©er un nouveau profil si pas trouv√© ou erreur
        return StudentProfile(
            student_id=student_id,
            name=student_name,
            last_session=datetime.now().isoformat()
        )
    
    def save_session(self, student_id: str) -> bool:
        """Sauvegarde la session d'un √©tudiant sur disque"""
        with self._session_lock:
            if student_id not in self._active_sessions:
                console.print(f"‚ö†Ô∏è Session {student_id} non trouv√©e pour sauvegarde")
                return False
            
            session = self._active_sessions[student_id]
            session.update_activity()
            
            try:
                import json
                student_file = self.data_dir / f"{student_id}.json"
                
                with open(student_file, 'w', encoding='utf-8') as f:
                    json.dump(session.student_profile.model_dump(), f, indent=4)
                
                # Synchroniser avec la m√©moire long terme si disponible
                if session.memory:
                    self._sync_to_memory(session)
                
                return True
                
            except Exception as e:
                console.print(f"‚ùå Erreur sauvegarde session {student_id}: {str(e)}")
                return False
    
    def _sync_to_memory(self, session: StudentSession):
        """Synchronise les donn√©es de session avec la m√©moire long terme"""
        if not session.memory:
            return
        
        try:
            student = session.student_profile
            
            # Ajouter les objectifs compl√©t√©s
            for obj in student.objectives_completed:
                session.memory.upsert_memory(
                    content=f"Objectif compl√©t√©: {obj}",
                    metadata={
                        "type": "achievement",
                        "objective": obj,
                        "timestamp": datetime.now().isoformat()
                    },
                    id=f"achievement_{student.student_id}_{obj}"
                )
            
            # Ajouter l'historique r√©cent (derniers 5 exercices)
            recent_history = student.learning_history[-5:] if student.learning_history else []
            for i, item in enumerate(recent_history):
                session.memory.upsert_memory(
                    content=f"Exercice: {item['exercise']} - R√©ponse: {item['answer']}",
                    metadata={
                        "type": "exercise",
                        "correct": str(item.get("evaluation", False)),
                        "timestamp": item.get("timestamp", datetime.now().isoformat()),
                        "concept": item.get("concept", "")
                    },
                    id=f"exercise_{student.student_id}_{len(student.learning_history)-5+i}"
                )
            
        except Exception as e:
            console.print(f"‚ö†Ô∏è Erreur sync m√©moire: {str(e)}")
    
    def update_session_data(self, student_id: str, key: str, value) -> bool:
        """Met √† jour les donn√©es temporaires de session"""
        with self._session_lock:
            if student_id in self._active_sessions:
                session = self._active_sessions[student_id]
                session.session_data[key] = value
                session.update_activity()
                return True
            return False
    
    def get_session_data(self, student_id: str, key: str, default=None):
        """R√©cup√®re une donn√©e temporaire de session"""
        with self._session_lock:
            if student_id in self._active_sessions:
                session = self._active_sessions[student_id]
                return session.session_data.get(key, default)
            return default
    
    def cleanup_expired_sessions(self) -> int:
        """Nettoie les sessions expir√©es et retourne le nombre nettoy√©"""
        with self._session_lock:
            expired_sessions = [
                student_id for student_id, session in self._active_sessions.items()
                if session.is_expired(self.session_timeout_minutes)
            ]
            
            for student_id in expired_sessions:
                self._cleanup_session(student_id)
            
            if expired_sessions:
                console.print(f"üßπ {len(expired_sessions)} sessions expir√©es nettoy√©es")
            
            return len(expired_sessions)
    
    def _cleanup_session(self, student_id: str):
        """Nettoie une session sp√©cifique"""
        if student_id in self._active_sessions:
            # Sauvegarder avant de nettoyer
            self.save_session(student_id)
            # Supprimer de la m√©moire
            del self._active_sessions[student_id]
    
    def get_active_sessions_count(self) -> int:
        """Retourne le nombre de sessions actives"""
        with self._session_lock:
            return len(self._active_sessions)
    
    def get_sessions_info(self) -> Dict:
        """Retourne des informations sur les sessions actives"""
        with self._session_lock:
            return {
                "active_sessions": len(self._active_sessions),
                "sessions": {
                    student_id: {
                        "name": session.student_profile.name,
                        "level": session.student_profile.level,
                        "last_activity": session.last_activity.isoformat(),
                        "expires_at": (session.last_activity + timedelta(minutes=self.session_timeout_minutes)).isoformat(),
                        "has_memory": session.memory is not None
                    }
                    for student_id, session in self._active_sessions.items()
                }
            }
    
    def force_save_all_sessions(self) -> int:
        """Force la sauvegarde de toutes les sessions actives"""
        with self._session_lock:
            saved_count = 0
            for student_id in self._active_sessions.keys():
                if self.save_session(student_id):
                    saved_count += 1
            
            console.print(f"üíæ {saved_count} sessions sauvegard√©es")
            return saved_count
    
    def close_session(self, student_id: str) -> bool:
        """Ferme explicitement une session (avec sauvegarde)"""
        with self._session_lock:
            if student_id in self._active_sessions:
                self.save_session(student_id)
                del self._active_sessions[student_id]
                console.print(f"üîö Session ferm√©e pour {student_id}")
                return True
            return False
    
    def shutdown(self):
        """Arr√™t propre du gestionnaire de sessions"""
        console.print("üõë Arr√™t du SessionManager...")
        self.force_save_all_sessions()
        if self.chroma_client:
            try:
                # ChromaDB ne n√©cessite pas de fermeture explicite
                pass
            except Exception as e:
                console.print(f"‚ö†Ô∏è Erreur fermeture ChromaDB: {str(e)}")
        console.print("‚úÖ SessionManager arr√™t√© proprement")

# D√©corateur pour faciliter l'usage avec les endpoints FastAPI
def with_session(func):
    """
    D√©corateur pour injecter automatiquement la session dans les endpoints
    Usage: @with_session puis ajouter session: StudentSession comme premier param√®tre
    """
    def wrapper(*args, **kwargs):
        # R√©cup√©rer student_id depuis les kwargs
        student_id = kwargs.get('student_id')
        if not student_id:
            raise ValueError("student_id requis pour with_session")
        
        # R√©cup√©rer le session_manager depuis l'instance globale (√† d√©finir dans FastAPI)
        from fastapi_main import session_manager  # Import sp√©cifique
        
        # Obtenir la session
        session = session_manager.get_or_create_session(student_id)
        
        # Injecter la session comme premier argument
        return func(session, *args, **kwargs)
    
    return wrapper